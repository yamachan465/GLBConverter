<!doctype html>
<meta charset="utf-8">
<link rel="icon" href="data:,">
<title>Images → GLB (Plane) → Zip</title>
<style>
  body { margin: 0; font-family: system-ui, sans-serif; background: #0b1224; color: #e5e7eb; }
  .wrap { max-width: 900px; margin: 40px auto; padding: 20px; background: #111827; border: 1px solid #1f2937; border-radius: 12px; }
  .drop { border: 2px dashed #334155; border-radius: 12px; padding: 40px; text-align: center; cursor: pointer; transition: border-color .2s, background .2s; }
  .drop.drag { border-color: #22d3ee; background: #0f172a; }
  button { background: #22c55e; border: 0; color: #0b1224; padding: 10px 16px; border-radius: 10px; font-weight: 700; cursor: pointer; }
  button:disabled { opacity: .5; cursor: not-allowed; }
  progress { width: 100%; }
  .log { font-size: 14px; line-height: 1.5; max-height: 240px; overflow: auto; background: #0b1224; border-radius: 8px; padding: 12px; }
</style>
<div class="wrap">
  <h2>Images → GLB (Plane) → Zip</h2>
  <div id="drop" class="drop">
    <p>ファイルをドロップ or クリックして選択（複数可）</p>
    <input id="file" type="file" accept="image/*" multiple style="display:none;">
  </div>
  <div style="margin:16px 0;">
    <label>長辺サイズ(m): <input id="size" type="number" step="0.1" value="1.0" style="width:80px;"></label>
    <label style="margin-left:12px;"><input id="double" type="checkbox" checked> 両面</label>
  </div>
  <button id="run">GLB生成してZipダウンロード</button>
  <div style="margin:12px 0;"><progress id="prog" max="1" value="0"></progress></div>
  <div class="log" id="log"></div>
</div>

<script type="module">
const loadModule = async (urls) => {
  for (const url of urls) {
    try { return await import(url); } catch (e) { console.warn("load fail", url, e?.message); }
  }
  throw new Error("必要なライブラリを読み込めませんでした（ネットワーク接続を確認してください）");
};

const {Document, WebIO} = await loadModule([
  "https://esm.sh/@gltf-transform/core@4.2.1?bundle",
  "https://esm.sh/@gltf-transform/core?bundle"
]);
const {KHRMaterialsUnlit} = await loadModule([
  "https://esm.sh/@gltf-transform/extensions@4.2.1?bundle",
  "https://esm.sh/@gltf-transform/extensions?bundle"
]);
const {zipSync} = await loadModule([
  "https://esm.sh/fflate@0.8.1?bundle",
  "https://esm.sh/fflate?bundle"
]);

const drop = document.getElementById("drop");
const fileInput = document.getElementById("file");
const runBtn = document.getElementById("run");
const logBox = document.getElementById("log");
const prog = document.getElementById("prog");
const imageExts = [".png", ".jpg", ".jpeg", ".webp", ".tif", ".tiff", ".tga"];

let files = [];
const log = (msg) => {
  logBox.textContent += msg + "\n";
  logBox.scrollTop = logBox.scrollHeight;
};

const isImageFile = (f) => {
  if (f?.type && f.type.startsWith("image/")) return true;
  const lower = f?.name?.toLowerCase() || "";
  return imageExts.some((ext) => lower.endsWith(ext));
};

drop.addEventListener("click", () => fileInput.click());
drop.addEventListener("dragover", (e) => { e.preventDefault(); drop.classList.add("drag"); });
drop.addEventListener("dragleave", () => drop.classList.remove("drag"));
drop.addEventListener("drop", (e) => {
  e.preventDefault();
  drop.classList.remove("drag");
  const incoming = [...e.dataTransfer.files];
  files = incoming.filter(isImageFile);
  log(files.length ? `選択: ${files.length}件 (${files.map((f) => f.name).join(", ")})` : "画像ファイルが見つかりません（png/jpg/webpなど）");
});
fileInput.addEventListener("change", (e) => {
  const incoming = [...e.target.files];
  files = incoming.filter(isImageFile);
  log(files.length ? `選択: ${files.length}件 (${files.map((f) => f.name).join(", ")})` : "画像ファイルが見つかりません（png/jpg/webpなど）");
});

runBtn.addEventListener("click", async () => {
  if (!files.length) return alert("画像を選択してください");
  runBtn.disabled = true;
  logBox.textContent = "";
  prog.value = 0;
  const longSide = parseFloat(document.getElementById("size").value) || 1.0;
  const doubleSided = document.getElementById("double").checked;

  try {
    const zipEntries = {};
    prog.max = files.length;
    for (let i = 0; i < files.length; i++) {
      const f = files[i];
      const glbBuf = await imageToGlb(f, {longSide, doubleSided});
      const outName = `Image${i + 1}.glb`; // 固定の連番命名
      zipEntries[outName] = new Uint8Array(glbBuf);
      prog.value = i + 1;
      log(`完了: ${outName}`);
    }
    const zip = zipSync(zipEntries, {level: 6});
    downloadBlob(new Blob([zip], {type: "application/zip"}), "planes.zip");
    log("Zipをダウンロードしました");
  } catch (e) {
    console.error(e);
    log("エラー: " + e.message);
  } finally {
    runBtn.disabled = false;
  }
});

async function imageToGlb(file, {longSide = 1.0, doubleSided = true}) {
  const imgData = new Uint8Array(await file.arrayBuffer());
  const {width, height} = await getImageSize(imgData);
  const aspect = width / height || 1;
  const w = width >= height ? longSide : longSide * aspect;
  const h = width >= height ? longSide / aspect : longSide;

  const doc = new Document();
  const io = new WebIO().registerExtensions([KHRMaterialsUnlit]);
  const tex = doc.createTexture(file.name).setImage(imgData).setMimeType(file.type || "image/png");
  const unlit = doc.createExtension(KHRMaterialsUnlit).createUnlit();
  const mat = doc.createMaterial("unlit")
    .setBaseColorTexture(tex)
    .setAlphaMode("BLEND")
    .setDoubleSided(doubleSided)
    .setExtension("KHR_materials_unlit", unlit);

  const positions = new Float32Array([
    -w / 2, -h / 2, 0,
     w / 2, -h / 2, 0,
     w / 2,  h / 2, 0,
    -w / 2,  h / 2, 0
  ]);
  const uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
  const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);

  const prim = doc.createPrimitive()
    .setAttribute("POSITION", doc.createAccessor().setType("VEC3").setArray(positions))
    .setAttribute("TEXCOORD_0", doc.createAccessor().setType("VEC2").setArray(uvs))
    .setIndices(doc.createAccessor().setArray(indices))
    .setMaterial(mat);

  const mesh = doc.createMesh().addPrimitive(prim);
  const node = doc.createNode("plane").setMesh(mesh).setRotation([Math.PI / 2, 0, 0]);
  doc.createScene().addChild(node);

  return io.writeBinary(doc);
}

function downloadBlob(blob, name) {
  const url = URL.createObjectURL(blob);
  const a = Object.assign(document.createElement("a"), {href: url, download: name});
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function getImageSize(uint8) {
  return new Promise((resolve, reject) => {
    const blob = new Blob([uint8]);
    const img = new Image();
    img.onload = () => resolve({width: img.naturalWidth, height: img.naturalHeight});
    img.onerror = reject;
    img.src = URL.createObjectURL(blob);
  });
}
</script>
